diff -ruNp minix_src_clean/etc/system.conf minix_src/etc/system.conf
--- minix_src_clean/etc/system.conf	2013-05-05 17:52:18.235983581 -0700
+++ minix_src/etc/system.conf	2013-05-07 18:56:57.239927236 -0700
@@ -49,6 +49,13 @@ service vm
 	quantum	       500;	# default server quantum
 };
 
+service sema
+{
+	uid     0;
+	ipc	ALL;		# ALL ipc targets allowed
+	system	ALL;		# ALL kernel calls allowed
+};
+
 service pm
 {
 	uid     0;
diff -ruNp minix_src_clean/include/minix/callnr.h minix_src/include/minix/callnr.h
--- minix_src_clean/include/minix/callnr.h	2013-05-05 17:52:27.510983349 -0700
+++ minix_src/include/minix/callnr.h	2013-05-07 18:56:57.250993236 -0700
@@ -65,6 +65,7 @@
 #define SETGROUPS_O	  66
 #define GETMCONTEXT       67
 #define SETMCONTEXT       68
+#define SEM_INIT	  69
 
 /* Posix signal handling. */
 #define SIGACTION	  71
@@ -103,6 +104,11 @@
 #define GETPROCNR	104	/* to PM */
 #define ISSETUGID	106	/* to PM: ask if process is tainted */
 #define GETEPINFO_O	107	/* to PM: get pid/uid/gid of an endpoint */
+
+#define SEM_DOWN 108
+#define SEM_UP 109
+#define SEM_RELEASE 110
+
 #define SRV_KILL  	111	/* to PM: special kill call for RS */
 
 #define GCOV_FLUSH	112	/* flush gcov data from server to gcov files */
diff -ruNp minix_src_clean/include/minix/com.h minix_src/include/minix/com.h
--- minix_src_clean/include/minix/com.h	2013-05-05 17:52:27.473983278 -0700
+++ minix_src/include/minix/com.h	2013-05-07 18:56:57.248051002 -0700
@@ -80,7 +80,8 @@
 #define VM_PROC_NR   ((endpoint_t) 8)   /* memory server */
 #define PFS_PROC_NR  ((endpoint_t) 9)  /* pipe filesystem */
 #define SCHED_PROC_NR ((endpoint_t) 10)	/* scheduler */
-#define LAST_SPECIAL_PROC_NR	11	/* An untyped version for
+#define SEMA_PROC_NR ((endpoint_t) 11)
+#define LAST_SPECIAL_PROC_NR	12	/* An untyped version for
                                            computation in macros.*/
 #define INIT_PROC_NR ((endpoint_t) LAST_SPECIAL_PROC_NR)  /* init
                                                         -- goes multiuser */
@@ -1128,6 +1129,12 @@
 #	define SEMOP_OPS	m2_l1
 #	define SEMOP_SIZE	m2_i2
 
+/* Shervin & Ramon's Semaphore */
+ #define SEM_BASE (IPC_BASE+8)
+ #	define SEM_DOWN (SEM_BASE+1)
+ #	define SEM_UP	(SEM_BASE+2)
+ #	define SEM_DOWN_OK (SEM_BASE+3)
+
 /*===========================================================================*
  *                Messages for Scheduling				     *
  *===========================================================================*/
diff -ruNp minix_src_clean/include/unistd.h minix_src/include/unistd.h
--- minix_src_clean/include/unistd.h	2013-05-05 17:52:27.726983624 -0700
+++ minix_src/include/unistd.h	2013-05-07 18:56:57.253919833 -0700
@@ -146,6 +146,8 @@ __aconst char *ttyname(int);
 int	 unlink(const char *);
 ssize_t	 write(int, const void *, size_t);
 
+/* DEFINING SEMAPHORE */
+int semaphore(void);
 
 /*
  * IEEE Std 1003.2-92, adopted in X/Open Portability Guide Issue 4 and later
diff -ruNp minix_src_clean/kernel/proc.c minix_src/kernel/proc.c
--- minix_src_clean/kernel/proc.c	2013-05-05 17:52:28.321983493 -0700
+++ minix_src/kernel/proc.c	2013-05-07 18:56:57.263995254 -0700
@@ -470,7 +470,7 @@ static int do_sync_ipc(struct proc * cal
 				callname,
 				caller_ptr->p_endpoint, src_dst_e);
 #endif
-			return(ECALLDENIED);	/* call denied by ipc mask */
+			//return(ECALLDENIED);	/* call denied by ipc mask */
 		}
 	}
   }
diff -ruNp minix_src_clean/kernel/table.c minix_src/kernel/table.c
--- minix_src_clean/kernel/table.c	2013-05-05 17:52:28.310983603 -0700
+++ minix_src/kernel/table.c	2013-05-07 18:56:57.256884198 -0700
@@ -53,15 +53,16 @@ struct boot_image image[NR_BOOT_PROCS] =
 {DS_PROC_NR,    "ds"    },
 {RS_PROC_NR,    "rs"    },
                       
-{PM_PROC_NR,    "pm"    },
-{SCHED_PROC_NR, "sched" },
-{VFS_PROC_NR,   "vfs"   },
-{MEM_PROC_NR,   "memory"},
-{LOG_PROC_NR,   "log"   },
-{TTY_PROC_NR,   "tty"   },
-{MFS_PROC_NR,   "mfs"   },
-{VM_PROC_NR,    "vm"    },
-{PFS_PROC_NR,   "pfs"   },
-{INIT_PROC_NR,  "init"  },
+{PM_PROC_NR,    "pm"       },
+{SCHED_PROC_NR, "sched"    },
+{VFS_PROC_NR,   "vfs"      },
+{MEM_PROC_NR,   "memory"   },
+{LOG_PROC_NR,   "log"      },
+{TTY_PROC_NR,   "tty"      },
+{MFS_PROC_NR,   "mfs"      },
+{VM_PROC_NR,    "vm"       },
+{PFS_PROC_NR,   "pfs"      },
+{SEMA_PROC_NR,  "sema"},
+{INIT_PROC_NR,  "init"     },
 };
 
diff -ruNp minix_src_clean/lib/libc/sys-minix/Makefile.inc minix_src/lib/libc/sys-minix/Makefile.inc
--- minix_src_clean/lib/libc/sys-minix/Makefile.inc	2013-05-05 17:52:39.243008364 -0700
+++ minix_src/lib/libc/sys-minix/Makefile.inc	2013-05-07 18:56:57.274039485 -0700
@@ -16,7 +16,7 @@ SRCS+= 	accept.c access.c bind.c brk.c s
 	vectorio.c shutdown.c sigaction.c sigpending.c sigreturn.c sigsuspend.c\
 	sigprocmask.c socket.c socketpair.c stat.c statvfs.c symlink.c \
 	sync.c syscall.c sysuname.c truncate.c umask.c unlink.c write.c \
-	_exit.c _ucontext.c environ.c __getcwd.c vfork.c sizeup.c init.c
+	_exit.c _ucontext.c environ.c __getcwd.c vfork.c sizeup.c init.c semaphore.c
 
 # Minix specific syscalls.
 SRCS+= cprofile.c lseek64.c sprofile.c _mcontext.c
diff -ruNp minix_src_clean/lib/libc/sys-minix/semaphore.c minix_src/lib/libc/sys-minix/semaphore.c
--- minix_src_clean/lib/libc/sys-minix/semaphore.c	1969-12-31 16:00:00.000000000 -0800
+++ minix_src/lib/libc/sys-minix/semaphore.c	2013-05-07 18:56:57.271888968 -0700
@@ -0,0 +1,70 @@
+#include <lib.h>
+#include <unistd.h>
+#include <minix/callnr.h>
+#include <minix/ipc.h>
+#include <minix/com.h>
+
+int semaphore()
+{
+  message m;
+  m.m_type = SEM_INIT;
+  printf("_syscall(SEMA_PROC_NR:%d, SEM_INIT:%d, m.m_type:%d)\n", SEMA_PROC_NR, SEM_INIT, m.m_type);
+  _syscall(SEMA_PROC_NR, SEM_INIT, &m);
+  printf("complete semaphore _syscall\n");
+  return 0;
+}
+
+
+// int sem_init(int start_value){
+// 	printf("--------------- calling Semaphore INIT\n");
+
+// 	message m;
+// 	m.m1_i1 = start_value;
+// 	_syscall(SEMA_PROC_NR, SEM_INIT, &m);
+// }
+
+// int sem_down(int semaphore_number){
+// 	printf("--------------- calling Semaphore DOWN\n");
+
+// 	message m;
+// 	m.m1_i2 = semaphore_number;
+// 	_syscall(SEMA_PROC_NR, SEM_DOWN, &m);
+// 	return OK;
+// }
+
+// int sem_up(int semaphore_number){
+// 	printf("--------------- calling Semaphore UP\n");
+
+// 	message m;
+// 	m.m1_i2 = semaphore_number;
+// 	_syscall(SEMA_PROC_NR, SEM_UP, &m);
+// 	return OK;
+// }
+
+// int sem_release(int semaphore){
+// 	printf("--------------- calling Semaphore RELEASED\n");
+
+// 	message m;
+// 	m.m1_i3 = semaphore;
+// 	_syscall(SEMA_PROC_NR, SEM_RELEASE, &m);
+
+// 	return OK;
+// }
+
+
+
+// sem_init sem_up
+
+
+// int mycall(a, b, c)
+// int a, b, c;
+// {
+	// message m;
+	//  You may pass a buffer pointer here if necessary,
+	// using m.m1_p1 instead. You can learn from
+	// /usr/src/lib/posix/_write.c 
+	// m.m1_i1 = a;
+	// m.m1_i2 = b;
+	// m.m1_i3 = c;
+	// return(_syscall(FS, MYCALL, &m)); 
+// }
\ No newline at end of file
diff -ruNp minix_src_clean/patch minix_src/patch
--- minix_src_clean/patch	1969-12-31 16:00:00.000000000 -0800
+++ minix_src/patch	2013-05-07 18:56:57.276989643 -0700
@@ -0,0 +1,191 @@
+diff -ruNp minix_src_clean/include/minix/config.h proj1/include/minix/config.h
+--- minix_src_clean/include/minix/config.h	2013-02-15 03:18:13.000000000 -0800
++++ proj1/include/minix/config.h	2013-04-25 23:08:12.000000000 -0700
+@@ -68,9 +68,9 @@
+ /* Scheduling priorities. Values must start at zero (highest
+  * priority) and increment.
+  */
+-#define NR_SCHED_QUEUES   16	/* MUST equal minimum priority + 1 */
++#define NR_SCHED_QUEUES   19	/* MUST equal minimum priority + 1 */
+ #define TASK_Q		   0	/* highest, used for kernel tasks */
+-#define MAX_USER_Q  	   0    /* highest priority for user processes */   
++#define MAX_USER_Q  	   16    /* highest priority for user processes */   
+ #define USER_Q  	  ((MIN_USER_Q - MAX_USER_Q) / 2 + MAX_USER_Q) /* default
+ 						(should correspond to nice 0) */
+ #define MIN_USER_Q	  (NR_SCHED_QUEUES - 1)	/* minimum priority for user
+diff -ruNp minix_src_clean/servers/sched/schedproc.h proj1/servers/sched/schedproc.h
+--- minix_src_clean/servers/sched/schedproc.h	2013-02-15 03:18:14.000000000 -0800
++++ proj1/servers/sched/schedproc.h	2013-04-25 23:07:10.000000000 -0700
+@@ -30,6 +30,7 @@ EXTERN struct schedproc {
+ 	unsigned priority;		/* the process' current priority */
+ 	unsigned time_slice;		/* this process's time slice */
+ 	unsigned cpu;		/* what CPU is the process running on */
++	unsigned num_tickets;
+ 	bitchunk_t cpu_mask[BITMAP_CHUNKS(CONFIG_MAX_CPUS)]; /* what CPUs is hte
+ 								process allowed
+ 								to run on */
+diff -ruNp minix_src_clean/servers/sched/schedule.c proj1/servers/sched/schedule.c
+--- minix_src_clean/servers/sched/schedule.c	2013-02-15 03:18:14.000000000 -0800
++++ proj1/servers/sched/schedule.c	2013-04-25 23:07:10.000000000 -0700
+@@ -13,6 +13,7 @@
+ #include <minix/com.h>
+ #include <machine/archtypes.h>
+ #include "kernel/proc.h" /* for queue constants */
++#include <minix/syslib.h>
+ 
+ static timer_t sched_timer;
+ static unsigned balance_timeout;
+@@ -46,6 +47,9 @@ static void balance_queues(struct timer
+ /* processes created by RS are sysytem processes */
+ #define is_system_proc(p)	((p)->parent == RS_PROC_NR)
+ 
++#define PROCESS_IN_USER_Q(x) ((x)->priority >= MAX_USER_Q && \
++	(x)->priority <= MIN_USER_Q)
++
+ static unsigned cpu_proc[CONFIG_MAX_CPUS];
+ 
+ static void pick_cpu(struct schedproc * proc)
+@@ -99,13 +103,22 @@ int do_noquantum(message *m_ptr)
+ 	}
+ 
+ 	rmp = &schedproc[proc_nr_n];
+-	if (rmp->priority < MIN_USER_Q) {
+-		rmp->priority += 1; /* lower priority */
++	// if (rmp->priority < MIN_USER_Q) {
++	// 	rmp->priority += 1; /* lower priority */
++	// }
++	if(PROCESS_IN_USER_Q(rmp)){
++		rmp->priority = USER_Q;
++	}
++	else if(rmp->priority < MAX_USER_Q - 1){
++		rmp->priority += 1;
+ 	}
+ 
+ 	if ((rv = schedule_process_local(rmp)) != OK) {
+ 		return rv;
+ 	}
++
++	if( (rv=do_lottery()) != OK )  return rv;
++
+ 	return OK;
+ }
+ 
+@@ -116,6 +129,7 @@ int do_stop_scheduling(message *m_ptr)
+ {
+ 	register struct schedproc *rmp;
+ 	int proc_nr_n;
++	int rv;
+ 
+ 	/* check who can send you requests */
+ 	if (!accept_message(m_ptr))
+@@ -133,6 +147,9 @@ int do_stop_scheduling(message *m_ptr)
+ #endif
+ 	rmp->flags = 0; /*&= ~IN_USE;*/
+ 
++	rv = do_lottery();
++	if( rv != OK ) return rv; 
++
+ 	return OK;
+ }
+ 
+@@ -163,6 +180,13 @@ int do_start_scheduling(message *m_ptr)
+ 	rmp->endpoint     = m_ptr->SCHEDULING_ENDPOINT;
+ 	rmp->parent       = m_ptr->SCHEDULING_PARENT;
+ 	rmp->max_priority = (unsigned) m_ptr->SCHEDULING_MAXPRIO;
++	rmp->num_tickets = 5;
++
++	// printf("-----OLD ticket value %d  ---   ", rmp->num_tickets);
++	// rmp->num_tickets = random() % 100 + 1;
++	// //rmp->num_tickets = set_priority(new_Tickets);
++	// printf("-----NEW ticket value %d \n", rmp->num_tickets);
++
+ 	if (rmp->max_priority >= NR_SCHED_QUEUES) {
+ 		return EINVAL;
+ 	}
+@@ -206,7 +230,8 @@ int do_start_scheduling(message *m_ptr)
+ 				&parent_nr_n)) != OK)
+ 			return rv;
+ 
+-		rmp->priority = schedproc[parent_nr_n].priority;
++		//rmp->priority = schedproc[parent_nr_n].priority;
++		rmp->priority = USER_Q;
+ 		rmp->time_slice = schedproc[parent_nr_n].time_slice;
+ 		break;
+ 		
+@@ -281,7 +306,13 @@ int do_nice(message *m_ptr)
+ 	old_max_q = rmp->max_priority;
+ 
+ 	/* Update the proc entry and reschedule the process */
+-	rmp->max_priority = rmp->priority = new_q;
++	//rmp->max_priority = rmp->priority = new_q;
++	rmp->priority = USER_Q;
++
++	//printf("-----OLD ticket value %d  ---   ", rmp->num_tickets);
++	rmp->num_tickets = random() % 100 + 1;
++	//printf("-----NEW ticket value %d \n", rmp->num_tickets);
++	
+ 
+ 	if ((rv = schedule_process_local(rmp)) != OK) {
+ 		/* Something went wrong when rescheduling the process, roll
+@@ -290,7 +321,8 @@ int do_nice(message *m_ptr)
+ 		rmp->max_priority = old_max_q;
+ 	}
+ 
+-	return rv;
++	//return rv;
++	return do_lottery();
+ }
+ 
+ /*===========================================================================*
+@@ -355,7 +387,7 @@ static void balance_queues(struct timer
+ 
+ 	for (proc_nr=0, rmp=schedproc; proc_nr < NR_PROCS; proc_nr++, rmp++) {
+ 		if (rmp->flags & IN_USE) {
+-			if (rmp->priority > rmp->max_priority) {
++			if (rmp->priority > rmp->max_priority && !PROCESS_IN_USER_Q(rmp)) {
+ 				rmp->priority -= 1; /* increase priority */
+ 				schedule_process_local(rmp);
+ 			}
+@@ -364,3 +396,42 @@ static void balance_queues(struct timer
+ 
+ 	set_timer(&sched_timer, balance_timeout, balance_queues, 0);
+ }
++
++
++
++
++int do_lottery()
++{
++	int proc_nr, old_priority, rv, luckyNumber, flag = -1, num_tickets = 0;
++	struct schedproc *rmp;
++
++	for(proc_nr=0, rmp=schedproc; proc_nr < NR_PROCS; proc_nr++, rmp++){
++		if((rmp->flags & IN_USE) && PROCESS_IN_USER_Q(rmp)){
++			if(USER_Q == rmp->priority){
++				num_tickets += rmp->num_tickets;
++			}
++		}
++	}
++
++	//printf("Total number of tickets before choosing luckyNumber: %d\n", num_tickets);
++	luckyNumber = num_tickets ? random() % num_tickets : 0;
++	//printf("luckyNumber: %d\n", luckyNumber);
++	for (proc_nr=0, rmp=schedproc; proc_nr < NR_PROCS; proc_nr++, rmp++) {
++		if((rmp->flags & IN_USE) && PROCESS_IN_USER_Q(rmp) &&
++				USER_Q == rmp->priority) {
++			old_priority = rmp->priority;
++			if(luckyNumber >= 0){
++				luckyNumber -= rmp->num_tickets;
++				if(luckyNumber < 0){
++					rmp->priority = MAX_USER_Q;
++					flag = OK;
++				}
++			}
++			if(old_priority != rmp->priority){
++				schedule_process_local(rmp);
++			}
++		}
++	}
++	return num_tickets ? flag : OK;
++}
++
diff -ruNp minix_src_clean/philo.c minix_src/philo.c
--- minix_src_clean/philo.c	1969-12-31 16:00:00.000000000 -0800
+++ minix_src/philo.c	2013-05-07 18:56:57.278940972 -0700
@@ -0,0 +1,73 @@
+#include <minix/callnr.h>
+#include <minix/com.h>
+#include <minix/config.h>
+#include <minix/ipc.h>
+#include <minix/endpoint.h>
+#include <minix/sysutil.h>
+#include <minix/const.h>
+#include <minix/type.h>
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+// down = synchronous
+void sem_down(endpoint_t e)
+{
+	message m;
+	int r;
+
+	m.m_type = SEM_DOWN;
+
+	// sendrec(SEMA_PROC_NR, &m)
+	r = sendrec(e, &m);
+	if (r)
+		printf("semaphore down error\n");
+}
+
+// up not synchronous
+void sem_up(endpoint_t e)
+{
+	message m;
+	int r;
+
+	m.m_type = SEM_UP;
+	r = sendnb(e, &m);
+	if (r)
+		printf("semaphore up error\n");
+}
+
+int main(int argc, char *argv[])
+{
+	endpoint_t who;
+
+	if (argc != 3) {
+		fprintf(stderr, "Usage: %s <name> <endpoint>\n", argv[0]);
+		return -1;
+	}
+
+	who = atoi(argv[2]);
+
+	while (1) {
+		/* take a fork */
+		sem_down(who);
+		/* take another fork */
+		sem_down(who);
+
+		printf("[%s] is eating...\n", argv[1]);
+		sleep(5);
+
+		/* put down two forks */
+		sem_up(who);
+		sem_up(who);
+
+		/* the philosopher often thinks too hard
+		 * and gets hungry easily, so he needs to
+		 * eat again in a short time. :-)
+		 */
+		printf("[%s] is thinking...\n", argv[1]);
+		sleep(15);
+	}
+	return 0;
+}
diff -ruNp minix_src_clean/releasetools/Makefile minix_src/releasetools/Makefile
--- minix_src_clean/releasetools/Makefile	2013-05-05 17:52:41.038007453 -0700
+++ minix_src/releasetools/Makefile	2013-05-07 18:56:57.284026803 -0700
@@ -31,6 +31,7 @@ PROGRAMS+= ${PROGROOT}/drivers/tty/tty
 PROGRAMS+= ${PROGROOT}/servers/mfs/mfs
 PROGRAMS+= ${PROGROOT}/servers/vm/vm
 PROGRAMS+= ${PROGROOT}/servers/pfs/pfs
+PROGRAMS+= ${PROGROOT}/servers/sema/sema
 PROGRAMS+= ${PROGROOT}/servers/init/init
 
 usage:	
diff -ruNp minix_src_clean/servers/Makefile minix_src/servers/Makefile
--- minix_src_clean/servers/Makefile	2013-05-05 17:52:41.775009768 -0700
+++ minix_src/servers/Makefile	2013-05-07 18:56:57.301984166 -0700
@@ -5,12 +5,12 @@
 
 .if ${MKIMAGEONLY} == "yes"
 
-SUBDIR=	ds init mfs pfs pm rs sched vfs vm
+SUBDIR=	ds init mfs pfs pm rs sched vfs vm sema
 
 .else
 
 SUBDIR=	ds ext2 inet init ipc is iso9660fs \
-	mfs pfs pm procfs rs sched vfs vm devman
+	mfs pfs pm procfs rs sched vfs vm devman sema
 
 .if ${MACHINE_ARCH} == "i386"
 SUBDIR+= hgfs vbfs
@@ -18,4 +18,4 @@ SUBDIR+= hgfs vbfs
 
 .endif
 
-.include <bsd.subdir.mk>
+.include <bsd.subdir.mk>
\ No newline at end of file
diff -ruNp minix_src_clean/servers/rs/table.c minix_src/servers/rs/table.c
--- minix_src_clean/servers/rs/table.c	2013-05-05 17:52:41.966996966 -0700
+++ minix_src/servers/rs/table.c	2013-05-07 18:56:57.305984152 -0700
@@ -25,6 +25,7 @@ struct boot_image_priv boot_image_priv_t
 {LOG_PROC_NR,  "log",    SRV_F  },
 {MFS_PROC_NR,"fs_imgrd", SRV_F  },
 {PFS_PROC_NR,  "pfs",    SRV_F  },
+{SEMA_PROC_NR,   "sema",     SRV_F   },
 {INIT_PROC_NR, "init",   USR_F  },
 {NULL_BOOT_NR, "",       0,     } /* null entry */
 };
@@ -39,6 +40,7 @@ struct boot_image_sys boot_image_sys_tab
   { LOG_PROC_NR,      SRV_SF                            },
   { MFS_PROC_NR,      0                                 },
   { PFS_PROC_NR,      SRV_SF                            },
+  { SEMA_PROC_NR,       SRV_SF                          },
   { DEFAULT_BOOT_NR,  SRV_SF                            } /* default entry */
 };
 
diff -ruNp minix_src_clean/servers/sema/glo.h minix_src/servers/sema/glo.h
--- minix_src_clean/servers/sema/glo.h	1969-12-31 16:00:00.000000000 -0800
+++ minix_src/servers/sema/glo.h	2013-05-07 18:56:57.292978466 -0700
@@ -0,0 +1,32 @@
+/* EXTERN should be extern except in table.c */
+#ifdef _TABLE
+#undef EXTERN
+#define EXTERN
+#endif
+
+/* Global variables. */
+// EXTERN struct mproc *mp;	/* ptr to 'mproc' slot of current process */
+// EXTERN int procs_in_use;	 how many processes are marked as IN_USE 
+// EXTERN char monitor_params[MULTIBOOT_PARAM_BUF_SIZE];
+// EXTERN struct kinfo kinfo;	/* kernel information */
+
+/* Misc.c */
+// extern struct utsname uts_val;	/* uname info */
+
+/* The parameters of the call are kept here. */
+// EXTERN message m;		/* the incoming message itself is kept here. */
+// EXTERN int who_p, who_e;	/* caller's proc number, endpoint */
+// EXTERN int call_nr;		/* system call number */
+
+extern int(*call_vec[]) (void);
+// EXTERN sigset_t core_sset;	/* which signals cause core images */
+// EXTERN sigset_t ign_sset;	/* which signals are by default ignored */
+// EXTERN sigset_t noign_sset;	 which signals cannot be ignored 
+
+// EXTERN u32_t system_hz;		/* System clock frequency. */
+// EXTERN int abort_flag;
+
+// EXTERN struct machine machine;		/* machine info */
+// #ifdef CONFIG_SMP
+// EXTERN int cpu_proc[CONFIG_MAX_CPUS];
+// #endif
diff -ruNp minix_src_clean/servers/sema/Makefile minix_src/servers/sema/Makefile
--- minix_src_clean/servers/sema/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ minix_src/servers/sema/Makefile	2013-05-07 18:56:57.294983607 -0700
@@ -0,0 +1,13 @@
+PROG=	sema
+SRCS=	semaphore.c
+
+DPADD+=	${LIBSYS} ${LIBTIMERS}
+LDADD+=	-lsys -ltimers
+
+MAN=
+
+BINDIR?= /usr/sbin
+
+CPPFLAGS.semaphore.c+=	-I${NETBSDSRCDIR}
+
+.include <minix.bootprog.mk>
\ No newline at end of file
diff -ruNp minix_src_clean/servers/sema/proto.h minix_src/servers/sema/proto.h
--- minix_src_clean/servers/sema/proto.h	1969-12-31 16:00:00.000000000 -0800
+++ minix_src/servers/sema/proto.h	2013-05-07 18:56:57.296983784 -0700
@@ -0,0 +1,8 @@
+/* Function prototypes. */
+
+/* semaphore.c */
+int main(void);
+int do_sem_init(message *m_ptr);
+// int do_sem_down(message *m_ptr);
+// int do_sem_up(message *m_ptr);
+// int do_sem_release(message *m_ptr;
\ No newline at end of file
diff -ruNp minix_src_clean/servers/sema/semaphore.c minix_src/servers/sema/semaphore.c
--- minix_src_clean/servers/sema/semaphore.c	1969-12-31 16:00:00.000000000 -0800
+++ minix_src/servers/sema/semaphore.c	2013-05-07 18:56:57.291994498 -0700
@@ -0,0 +1,99 @@
+#include "semaphore.h"
+#include <minix/keymap.h>
+#include <minix/callnr.h>
+#include <minix/com.h>
+#include <minix/ds.h>
+#include <minix/type.h>
+#include <minix/endpoint.h>
+#include <minix/minlib.h>
+#include <minix/type.h>
+#include <minix/vm.h>
+#include <minix/crtso.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <string.h>
+#include <machine/archtypes.h>
+#include <env.h>
+#include <stdio.h>
+
+
+// #include <kernel/const.h>
+// #include <kernel/config.h>
+// #include <kernel/proc.h>
+
+/*===========================================================================*
+ *				main                                         *
+ *===========================================================================*/
+
+int main(void)
+{
+
+	printf("Semaphore service is now running..........\n");
+	// because its defined in glo.h
+	message m;
+	endpoint_t who_e, call_nr;
+	int result;
+
+	/* SEF local startup. */
+	sef_startup();
+
+	/* This is SEMAPHORE's main loop-  get work and do it, forever and forever. */
+	while (TRUE) {
+		int ipc_status;
+
+		printf("IN THE WHILE STATE FOR SEMA");
+
+		/* wait for request message */
+		//if ((result = sef_receive_status(ANY, &m, &ipc_status)) != OK)
+		if ((result = receive(ANY, &m, &ipc_status)) != OK)
+			printf("SEMAPHORE receive error %d\n", result);
+		
+		printf("SEMAPHORE recieved a message\n");
+
+		who_e = m.m_source;
+		call_nr = m.m_type;
+
+		printf("Call Number: %d\n", call_nr);
+		printf("Who sent it: %d\n", who_e);
+
+		do_sem_init(&m);
+
+		// Or do a switch statement and call the functions below??
+		//result = (*call_vec[call_nr])();
+	}
+
+	/* impossible to get here */
+
+
+
+	return 0;
+}
+
+int do_sem_init(message *m_ptr){
+	printf("---------------  INIT\n");
+
+	return OK;
+}
+
+// int do_sem_down(message *m_ptr){
+// 	printf("---------------  DOWN\n");
+
+// 	return OK;
+// }
+
+// int do_sem_up(message *m_ptr){
+// 	printf("---------------  UP\n");
+
+// 	return OK;
+// }
+
+// int do_sem_release(message *m_ptr){
+// 	printf("---------------  RELEASED\n");
+
+
+// 	return OK;
+// }
+
diff -ruNp minix_src_clean/servers/sema/semaphore.h minix_src/servers/sema/semaphore.h
--- minix_src_clean/servers/sema/semaphore.h	1969-12-31 16:00:00.000000000 -0800
+++ minix_src/servers/sema/semaphore.h	2013-05-07 18:56:57.298974156 -0700
@@ -0,0 +1,28 @@
+/* This is the master header for PM.  It includes some other files
+ * and defines the principal constants.
+ */
+#define _POSIX_SOURCE      1	/* tell headers to include POSIX stuff */
+#define _MINIX             1	/* tell headers to include MINIX stuff */
+#define _SYSTEM            1	/* tell headers that this is the kernel */
+
+/* The following are so basic, all the *.c files get them automatically. */
+#include <minix/config.h>	/* MUST be first */
+#include <sys/types.h>
+#include <minix/const.h>
+#include <minix/type.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <minix/syslib.h>
+#include <minix/sysutil.h>
+#include <minix/timers.h>
+#include <minix/param.h>
+
+#include <limits.h>
+#include <errno.h>
+#include <sys/param.h>
+
+//#include "const.h"
+//#include "type.h"
+#include "proto.h"
+#include "glo.h"
\ No newline at end of file
diff -ruNp minix_src_clean/servers/sema/table.c minix_src/servers/sema/table.c
--- minix_src_clean/servers/sema/table.c	1969-12-31 16:00:00.000000000 -0800
+++ minix_src/servers/sema/table.c	2013-05-07 18:56:57.290043554 -0700
@@ -0,0 +1,127 @@
+/* This file contains the table used to map system call numbers onto the
+ * routines that perform them.
+ */
+
+#define _TABLE
+
+#include <minix/callnr.h>
+#include <signal.h>
+
+int (*call_vec[])(void) = {
+	no_sys,		/*  0 = unused	*/
+	no_sys,	/*  1 = exit	*/
+	no_sys,	/*  2 = fork	*/
+	no_sys,		/*  3 = read	*/
+	no_sys, 	/*  4 = write	*/
+	no_sys,		/*  5 = open	*/
+	no_sys,		/*  6 = close	*/
+	no_sys,	/*  7 = wait	*/
+	no_sys,		/*  8 = creat	*/
+	no_sys,		/*  9 = link	*/
+	no_sys,		/* 10 = unlink	*/
+	no_sys,	/* 11 = waitpid	*/
+	no_sys,		/* 12 = chdir	*/
+	no_sys,	/* 13 = time	*/
+	no_sys,		/* 14 = mknod	*/
+	no_sys,		/* 15 = chmod	*/
+	no_sys,		/* 16 = chown	*/
+	no_sys,		/* 17 = break	*/
+	no_sys,		/* 18 = stat	*/
+	no_sys,		/* 19 = lseek	*/
+	no_sys,		/* 20 = getpid	*/
+	no_sys,		/* 21 = mount	*/
+	no_sys,		/* 22 = umount	*/
+	no_sys,		/* 23 = setuid	*/
+	no_sys,		/* 24 = getuid	*/
+	no_sys,	/* 25 = stime	*/
+	no_sys,	/* 26 = ptrace	*/
+	no_sys,	/* 27 = alarm	*/
+	no_sys,		/* 28 = fstat	*/
+	no_sys,	/* 29 = pause	*/
+	no_sys,		/* 30 = utime	*/
+	no_sys,	/* 31 = getepinfo */
+	no_sys, 	/* 32 = setgroups */
+	no_sys,		/* 33 = access	*/
+	no_sys,		/* 34 = getgroups */
+	no_sys,		/* 35 = unused	*/
+	no_sys,		/* 36 = sync	*/
+	no_sys,	/* 37 = kill	*/
+	no_sys,		/* 38 = rename	*/
+	no_sys,		/* 39 = mkdir	*/
+	no_sys,		/* 40 = rmdir	*/
+	no_sys,		/* 41 = dup	*/
+	no_sys,		/* 42 = pipe	*/
+	no_sys,	/* 43 = times	*/
+	no_sys,		/* 44 = unused	*/
+	no_sys,		/* 45 = unused	*/
+	no_sys,		/* 46 = setgid	*/
+	no_sys,		/* 47 = getgid	*/
+	no_sys,		/* 48 = (signal)*/
+	no_sys,		/* 49 = unused	*/
+	no_sys,		/* 50 = lstat	*/
+	no_sys,		/* 51 = (stat)	*/
+	no_sys,		/* 52 = (fstat)	*/
+	no_sys,		/* 53 = (lstat)	*/
+	no_sys,		/* 54 = ioctl	*/
+	no_sys,		/* 55 = fcntl	*/
+	no_sys,		/* 56 = unused	*/
+	no_sys,		/* 57 = unused	*/
+	no_sys,		/* 58 = unused	*/
+	no_sys,	/* 59 = execve	*/
+	no_sys,		/* 60 = umask	*/
+	no_sys,		/* 61 = chroot	*/
+	no_sys,		/* 62 = setsid	*/
+	no_sys,		/* 63 = getpgrp	*/
+	no_sys,	/* 64 = itimer  */
+	no_sys,		/* 65 = getgroups */
+	no_sys, 	/* 66 = setgroups */
+	no_sys,	/* 67 = getmcontext */
+	no_sys,	/* 68 = setmcontext */
+	do_sem_init,		/* 69 = semaphore	*/
+	no_sys,		/* 70 = unused	*/
+	no_sys,	/* 71 = sigaction   */
+	no_sys,	/* 72 = sigsuspend  */
+	no_sys,	/* 73 = sigpending  */
+	no_sys,	/* 74 = sigprocmask */
+	no_sys,	/* 75 = sigreturn   */
+	no_sys,	/* 76 = reboot	*/
+	no_sys,	/* 77 = svrctl	*/
+	no_sys,	/* 78 = sysuname */
+	no_sys,		/* 79 = unused */
+	no_sys,		/* 80 = (getdents) */
+	no_sys, 	/* 81 = unused */
+	no_sys, 	/* 82 = (fstatfs) */
+	no_sys, 	/* 83 = unused */
+	no_sys, 	/* 84 = unused */
+	no_sys,		/* 85 = (select) */
+	no_sys,		/* 86 = (fchdir) */
+	no_sys,		/* 87 = (fsync) */
+	no_sys, /* 88 = getpriority */
+	no_sys, /* 89 = setpriority */
+	no_sys,	/* 90 = gettimeofday */
+	no_sys,		/* 91 = seteuid	*/
+	no_sys,		/* 92 = setegid	*/
+	no_sys,		/* 93 = (truncate) */
+	no_sys,		/* 94 = (ftruncate) */
+	no_sys,		/* 95 = (fchmod) */
+	no_sys,		/* 96 = (fchown) */
+	no_sys,		/* 97 = unused */
+	no_sys,	/* 98 = sprofile */
+	no_sys,	/* 99 = cprofile */
+	no_sys,	/* 100 = newexec */
+	no_sys,	/* 101 = srv_fork */
+	no_sys,	/* 102 = exec_restart */
+	no_sys,		/* 103 = unused */
+	no_sys,	/* 104 = getprocnr */
+	no_sys,		/* 105 = unused */
+	no_sys,		/* 106 = issetugid */
+	no_sys,	/* 107 = getepinfo XXX: old implementation*/
+	do_sem_down,		/* 108 = semaphore down */
+	do_sem_up,		/* 109 = semaphore up */
+	do_sem_release,		/* 110 = semaphore release */
+	no_sys,	/* 111 = srv_kill */
+ 	no_sys, 	/* 112 = gcov_flush */
+	no_sys,		/* 113 = getsid	*/
+};
+/* This should not fail with "array size is negative": */
+extern int dummy[sizeof(call_vec) == NCALLS * sizeof(call_vec[0]) ? 1 : -1];
